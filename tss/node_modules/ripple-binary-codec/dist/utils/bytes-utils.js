"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.serializeUIntN = exports.compareBytes = exports.slice = exports.bytesToHex = exports.parseBytes = void 0;
var assert_1 = require("assert");
function signum(a, b) {
    return a < b ? -1 : a === b ? 0 : 1;
}
var hexLookup = (function () {
    var res = {};
    var reverse = res.reverse = new Array(256);
    for (var i = 0; i < 16; i++) {
        var char = i.toString(16).toUpperCase();
        res[char] = i;
        for (var j = 0; j < 16; j++) {
            var char2 = j.toString(16).toUpperCase();
            var byte = (i << 4) + j;
            var byteHex = char + char2;
            res[byteHex] = byte;
            reverse[byte] = byteHex;
        }
    }
    return res;
}());
var reverseHexLookup = hexLookup.reverse;
function bytesToHex(sequence) {
    var buf = Array(sequence.length);
    for (var i = sequence.length - 1; i >= 0; i--) {
        buf[i] = reverseHexLookup[sequence[i]];
    }
    return buf.join('');
}
exports.bytesToHex = bytesToHex;
function byteForHex(hex) {
    var byte = hexLookup[hex];
    if (byte === undefined) {
        throw new Error("`" + hex + "` is not a valid hex representation of a byte");
    }
    return byte;
}
function parseBytes(val, Output) {
    if (Output === void 0) { Output = Array; }
    if (!val || val.length === undefined) {
        throw new Error(val + " is not a sequence");
    }
    if (typeof val === 'string') {
        var start = val.length % 2;
        var res_1 = new Output((val.length + start) / 2);
        for (var i = val.length, to = res_1.length - 1; to >= start; i -= 2, to--) {
            res_1[to] = byteForHex(val.slice(i - 2, i));
        }
        if (start === 1) {
            res_1[0] = byteForHex(val[0]);
        }
        return res_1;
    }
    else if (val instanceof Output) {
        return val;
    }
    else if (Output === Uint8Array) {
        return new Output(val);
    }
    var res = new Output(val.length);
    for (var i = val.length - 1; i >= 0; i--) {
        res[i] = val[i];
    }
    return res;
}
exports.parseBytes = parseBytes;
function serializeUIntN(val, width) {
    var newBytes = new Uint8Array(width);
    var lastIx = width - 1;
    for (var i = 0; i < width; i++) {
        newBytes[lastIx - i] = (val >>> (i * 8) & 0xff);
    }
    return newBytes;
}
exports.serializeUIntN = serializeUIntN;
function compareBytes(a, b) {
    assert_1.strict(a.length === b.length);
    for (var i = 0; i < a.length; i++) {
        var cmp = signum(a[i], b[i]);
        if (cmp !== 0) {
            return cmp;
        }
    }
    return 0;
}
exports.compareBytes = compareBytes;
function slice(val, startIx, endIx, Output) {
    if (startIx === void 0) { startIx = 0; }
    if (endIx === void 0) { endIx = val.length; }
    if (Output === void 0) { Output = val.constructor; }
    /* eslint-disable no-param-reassign */
    if (startIx < 0) {
        startIx += val.length;
    }
    if (endIx < 0) {
        endIx += val.length;
    }
    /* eslint-enable no-param-reassign */
    var len = endIx - startIx;
    var res = new Output(len);
    for (var i = endIx - 1; i >= startIx; i--) {
        res[i - startIx] = val[i];
    }
    return res;
}
exports.slice = slice;
//# sourceMappingURL=bytes-utils.js.map